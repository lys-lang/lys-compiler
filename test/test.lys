import support::env
import support::test
import src::main
import src::tokens

#[export]
fun test(): void = {
  START("Parser tests")

  case1()
  case2()
  case3()
  case4()
  whitespaces()
  strings()
  parentheses()
  macroDecorations()
  singleLineComment()

  END()
}

fun case1(): void = {
  START("case1")

  val p = Parser("A  BCS C DEF ghi123  ???")

  validateToken(p, Identifier, "A")
  validateToken(p, Whitespace, "  ")
  validateToken(p, Identifier, "BCS")
  validateToken(p, Whitespace, " ")
  validateToken(p, Identifier, "C")
  validateToken(p, Whitespace, " ")
  validateToken(p, Identifier, "DEF")
  validateToken(p, Whitespace, " ")
  validateToken(p, Identifier, "ghi123")
  validateToken(p, Whitespace, "  ")
  validateToken(p, Identifier, "???")
  validateToken(p, EndOfFile, "")
  validateToken(p, EndOfFile, "")

  END()
}


fun parentheses(): void = {
  {
    START("Parentheses")
    val p = Parser("asd( ))")

    validateToken(p, Identifier, "asd")
    validateToken(p, ParenthesesOpen, "(")
    validateToken(p, Whitespace, " ")
    validateToken(p, ParenthesesClose, ")")
    validateToken(p, ParenthesesClose, ")")

    validateToken(p, EndOfFile, "")
    END()
  }

  {
    START("Curly")
    val p = Parser("asd({}}))")

    validateToken(p, Identifier, "asd")
    validateToken(p, ParenthesesOpen, "(")
    validateToken(p, CurlyBracesOpen, "{")
    validateToken(p, CurlyBracesClose, "}")
    validateToken(p, CurlyBracesClose, "}")
    validateToken(p, ParenthesesClose, ")")
    validateToken(p, ParenthesesClose, ")")

    validateToken(p, EndOfFile, "")
    END()
  }
}

fun case2(): void = {
  START("Empty case")

  val p = Parser("")

  validateToken(p, EndOfFile, "")
  validateToken(p, EndOfFile, "")

  END()
}

fun case3(): void = {
  START("case3")

  val p = Parser("a  AA,, αρετη")

  validateToken(p, Identifier, "a")
  validateToken(p, Whitespace, "  ")
  validateToken(p, Identifier, "AA")
  validateToken(p, Comma, ",")
  validateToken(p, Comma, ",")
  validateToken(p, Whitespace, " ")
  validateToken(p, Identifier, "αρετη")
  validateToken(p, EndOfFile, "")

  END()
}

fun case4(): void = {
  START("case4")

  val p = Parser("asd   AA a")

  validateToken(p, Identifier, "asd")
  validateToken(p, Whitespace, "   ")
  validateToken(p, Identifier, "AA")
  validateToken(p, Whitespace, " ")
  validateToken(p, Identifier, "a")
  validateToken(p, EndOfFile, "")

  END()
}

fun whitespaces(): void = {
  START("Whitespaces")

  val p = Parser(" \n\r\t;")

  validateToken(p, Whitespace, " ")
  validateToken(p, NewLine, "\n\r")
  validateToken(p, Whitespace, "\t")
  validateToken(p, NewLine, ";")
  validateToken(p, EndOfFile, "")

  END()
}

fun strings(): void = {
  {
    START("Strings")
    val p = Parser(" \"asd\" \"\"  ")

    validateToken(p, Whitespace, " ")
    validateToken(p, StringLiteral, "\"asd\"")
    validateToken(p, Whitespace, " ")
    validateToken(p, StringLiteral, "\"\"")
    validateToken(p, Whitespace, "  ")
    validateToken(p, EndOfFile, "")
    END()
  }

  {
    START("Strings with comment")
    val p = Parser(" \"a/" ++ "/sd\" \"\"  ")

    validateToken(p, Whitespace, " ")
    validateToken(p, StringLiteral, "\"a/" ++ "/sd\"")
    validateToken(p, Whitespace, " ")
    validateToken(p, StringLiteral, "\"\"")
    validateToken(p, Whitespace, "  ")
    validateToken(p, EndOfFile, "")
    END()
  }
}


fun macroDecorations(): void = {
  START("Macro decoration")

  val p = Parser("#[exp#ort][]")

  validateToken(p, MacroDecoration, "#[")
  validateToken(p, Identifier, "exp")
  validateToken(p, Unknown, "#")
  validateToken(p, Identifier, "ort")
  validateToken(p, VectorClose, "]")
  validateToken(p, VectorOpen, "[")
  validateToken(p, VectorClose, "]")
  validateToken(p, EndOfFile, "")

  END()
}

fun singleLineComment(): void = {
  START("Single line comment")
  {
    val p = Parser("/"++"/ asd")

    validateToken(p, LineComment, "/"++"/ asd")
    validateToken(p, EndOfFile, "")

    END()
  }

  START("Single line comment 2")
  {
    val p = Parser("asd /" ++ "/ asd\n  asd")

    validateToken(p, Identifier, "asd")
    validateToken(p, Whitespace, " ")
    validateToken(p, LineComment, "/" ++ "/ asd\n")
    validateToken(p, Whitespace, "  ")
    validateToken(p, Identifier, "asd")
    validateToken(p, EndOfFile, "")

    END()
  }

  START("Multi line comment")
  {
    val p = Parser("asd /" ++ "* asd */\n  asd")

    validateToken(p, Identifier, "asd")
    validateToken(p, Whitespace, " ")
    validateToken(p, MultiLineComment, "/" ++ "* asd */")
    validateToken(p, NewLine, "\n")
    validateToken(p, Whitespace, "  ")
    validateToken(p, Identifier, "asd")
    validateToken(p, EndOfFile, "")

    END()
  }
}

fun validateToken(p: Parser, expectedToken: TokenType, expectedValue: string): void = {
  match p.eat() {
    case is Token(tokenType, start, end) -> {
      val given = TokenType.toString(tokenType)
      val expected = TokenType.toString(expectedToken)
      mustEqual(given, expected, "eat " ++ expected ++ "(" ++ expectedValue ++ ")")
      val givenValue = p.source.substring(start as i32, end as i32)
      mustEqual(givenValue, expectedValue, "value=(" ++ expectedValue ++ ")")
    }
  }
}
