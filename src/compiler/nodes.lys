import src::parser::parser
import src::stringbuilder

enum CodeNode {
  EmptyNode()
  ErrorNode(astNode: AstNode, desc: string)
  CodeNodeCons(head: CodeNode, tail: CodeNode)

  Document(astNode: AstNode, headDirective: CodeNode)

  PrivateModifierNode(astNode: AstNode)
  NoModifierNode(astNode: AstNode)

  NameIdentifierNode(astNode: AstNode, name: string)
  QNameNode(astNode: AstNode, names: CodeNode)
  FunctionTypeNode(astNode: AstNode, parameters: CodeNode, returnType: CodeNode, effect: CodeNode)
  EffectMemberDeclarationNode(astNode: AstNode)
  ReferenceNode(astNode: AstNode, variable: QNameNode | ErrorNode)
  BlockNode(astNode: AstNode, headStatement: CodeNode)
  MemberNode(astNode: AstNode, lhs: CodeNode, operator: string, rhs: CodeNode)
  DecoratorNode(astNode: AstNode, decoratorName: NameIdentifierNode | ErrorNode, headArgument: CodeNode)
  ParameterNode(astNode: AstNode, parameterName: NameIdentifierNode | ErrorNode, parameterType: CodeNode)
  FunctionNode(astNode: AstNode, functionName: NameIdentifierNode | ErrorNode, headParameter: CodeNode, returnType: CodeNode, body: CodeNode)
  VarDeclarationNode(astNode: AstNode, isMutable: boolean, name: NameIdentifierNode | ErrorNode, typeDecl: CodeNode, value: CodeNode)
  AssignmentNode(astNode: AstNode, lhs: CodeNode, rhs: CodeNode)

  ParenExpressionNode(astNode: AstNode, expression: CodeNode)

  ImplDirectiveNode(astNode: AstNode, baseImpl: ReferenceNode | EmptyNode, targetImpl: ReferenceNode | ErrorNode, headDirective: CodeNode)
  ImportDirectiveNode(astNode: AstNode, module: QNameNode | ErrorNode, alias: NameIdentifierNode | EmptyNode)
  FunDirectiveNode(astNode: AstNode, headDecorator: CodeNode, modifier: CodeNode, function: FunctionNode | ErrorNode)
  EffectDirectiveNode(astNode: AstNode, effectDecl: EffectDeclarationNode)
  OverloadedFunDirectiveNode(astNode: AstNode, functionName: NameIdentifierNode, headFun: CodeNode)
  VarDirectiveNode(astNode: AstNode, modifier: CodeNode, decl: VarDeclarationNode | EmptyNode)
  TypeDirectiveNode(astNode: AstNode, modifier: CodeNode, name: NameIdentifierNode | ErrorNode, declType: CodeNode)
  TraitDirectiveNode(astNode: AstNode, modifier: CodeNode, name: NameIdentifierNode | ErrorNode, headDirective: CodeNode)
  EnumDirectiveNode(astNode: AstNode, modifier: CodeNode, name: NameIdentifierNode | ErrorNode, headDeclaration: CodeNode)
  StructDirectiveNode(astNode: AstNode, modifier: CodeNode, decl: StructDeclarationNode | ErrorNode)

  FloatLiteralNode(astNode: AstNode, value: string)
  IntegerLiteralNode(astNode: AstNode, value: string)
  HexLiteralNode(astNode: AstNode, value: string)
  BooleanLiteralNode(astNode: AstNode, value: boolean)
  StringLiteralNode(astNode: AstNode, value: string)

  UnknownExpressionNode(astNode: AstNode)

  InjectedLiteralNode(astNode: AstNode)
  StackLiteralNode(astNode: AstNode, headNames: CodeNode)
  NameLiteralPairNode(astNode: AstNode, name: NameIdentifierNode | ErrorNode, value: CodeNode)

  StackTypeNode(astNode: AstNode, headMeta: CodeNode)
  StructTypeNode(astNode: AstNode, headParameter: CodeNode)

  AbstractFunctionCallNode(astNode: AstNode, headArgument: CodeNode, resolvedFunction: CodeNode)
  InjectedFunctionCallNode(astNode: AstNode, headArgument: CodeNode, resolvedFunction: CodeNode)

  FunctionCallNode(astNode: AstNode, functionNode: CodeNode, headArgument: CodeNode, resolvedFunction: CodeNode)

  BinaryExpressionNode(astNode: AstNode, lhs: CodeNode, operator: NameIdentifierNode | ErrorNode, rhs: CodeNode)
  AsExpressionNode(astNode: AstNode, lhs: CodeNode, rhs: CodeNode)
  IsExpressionNode(astNode: AstNode, lhs: CodeNode, rhs: CodeNode)
  UnaryExpressionNode(astNode: AstNode, operator: NameIdentifierNode | ErrorNode, rhs: CodeNode)
  WasmAtomNode(astNode: AstNode, symbol: string, headArgument: CodeNode)
  WasmExpressionNode(astNode: AstNode, headAtom: CodeNode)

  IfNode(astNode: AstNode, condition: CodeNode, truePart: CodeNode, falsePart: CodeNode)

  UnionTypeNode(astNode: AstNode, lhs: CodeNode, rhs: CodeNode)
  IntersectionTypeNode(astNode: AstNode, lhs: CodeNode, rhs: CodeNode)

  StructDeclarationNode(astNode: AstNode, name: NameIdentifierNode | ErrorNode, headParameter: CodeNode)
  EffectDeclarationNode(astNode: AstNode, name: NameIdentifierNode)

  PatternMatcherNode(astNode: AstNode, lhs: CodeNode, headMatcher: CodeNode)
  MatchConditionNode(astNode: AstNode, declaredName: NameIdentifierNode | EmptyNode, condition: CodeNode, body: CodeNode)
  MatchCaseIsNode(astNode: AstNode, declaredName: NameIdentifierNode | EmptyNode, typeReference: CodeNode, headDeconstruct: CodeNode, body: CodeNode)
  MatchLiteralNode(astNode: AstNode, literal: CodeNode, body: CodeNode)
  MatchDefaultNode(astNode: AstNode, declaredName: NameIdentifierNode | EmptyNode, body: CodeNode)

  LoopNode(astNode: AstNode, expression: CodeNode)
  ContinueNode(astNode: AstNode)
  BreakNode(astNode: AstNode)
}

impl CodeNode {

  #[method]
  fun nodeName(self: CodeNode): string = match self {
    case is EmptyNode -> "EmptyNode"
    case is ErrorNode -> "ErrorNode"
    case is CodeNodeCons -> "CodeNodeCons"
    case is Document -> "Document"
    case is PrivateModifierNode -> "PrivateModifierNode"
    case is NoModifierNode -> "NoModifierNode"
    case is NameIdentifierNode -> "NameIdentifierNode"
    case is QNameNode -> "QNameNode"
    case is FunctionTypeNode -> "FunctionTypeNode"
    case is EffectMemberDeclarationNode -> "EffectMemberDeclarationNode"
    case is ReferenceNode -> "ReferenceNode"
    case is BlockNode -> "BlockNode"
    case is MemberNode -> "MemberNode"
    case is DecoratorNode -> "DecoratorNode"
    case is ParameterNode -> "ParameterNode"
    case is FunctionNode -> "FunctionNode"
    case is VarDeclarationNode -> "VarDeclarationNode"
    case is AssignmentNode -> "AssignmentNode"
    case is ParenExpressionNode -> "ParenExpressionNode"
    case is ImplDirectiveNode -> "ImplDirectiveNode"
    case is ImportDirectiveNode -> "ImportDirectiveNode"
    case is FunDirectiveNode -> "FunDirectiveNode"
    case is EffectDirectiveNode -> "EffectDirectiveNode"
    case is StructDirectiveNode -> "StructDirectiveNode"
    case is OverloadedFunDirectiveNode -> "OverloadedFunDirectiveNode"
    case is VarDirectiveNode -> "VarDirectiveNode"
    case is TypeDirectiveNode -> "TypeDirectiveNode"
    case is TraitDirectiveNode -> "TraitDirectiveNode"
    case is EnumDirectiveNode -> "EnumDirectiveNode"
    case is FloatLiteralNode -> "FloatLiteralNode"
    case is IntegerLiteralNode -> "IntegerLiteralNode"
    case is HexLiteralNode -> "HexLiteralNode"
    case is BooleanLiteralNode -> "BooleanLiteralNode"
    case is StringLiteralNode -> "StringLiteralNode"
    case is UnknownExpressionNode -> "UnknownExpressionNode"
    case is StackTypeNode -> "StackTypeNode"
    case is StructTypeNode -> "StructTypeNode"
    case is AbstractFunctionCallNode -> "AbstractFunctionCallNode"
    case is InjectedFunctionCallNode -> "InjectedFunctionCallNode"
    case is FunctionCallNode -> "FunctionCallNode"
    case is BinaryExpressionNode -> "BinaryExpressionNode"
    case is AsExpressionNode -> "AsExpressionNode"
    case is IsExpressionNode -> "IsExpressionNode"
    case is UnaryExpressionNode -> "UnaryExpressionNode"
    case is WasmAtomNode -> "WasmAtomNode"
    case is WasmExpressionNode -> "WasmExpressionNode"
    case is IfNode -> "IfNode"
    case is UnionTypeNode -> "UnionTypeNode"
    case is IntersectionTypeNode -> "IntersectionTypeNode"
    case is StructDeclarationNode -> "StructDeclarationNode"
    case is EffectDeclarationNode -> "EffectDeclarationNode"
    case is PatternMatcherNode -> "PatternMatcherNode"
    case is MatchConditionNode -> "MatchConditionNode"
    case is MatchCaseIsNode -> "MatchCaseIsNode"
    case is MatchLiteralNode -> "MatchLiteralNode"
    case is MatchDefaultNode -> "MatchDefaultNode"
    case is LoopNode -> "LoopNode"
    case is ContinueNode -> "ContinueNode"
    case is BreakNode -> "BreakNode"
    case is InjectedLiteralNode -> "InjectedLiteralNode"
    case is StackLiteralNode -> "StackLiteralNode"
    case is NameLiteralPairNode -> "NameLiteralPairNode"
  }

  fun printWithSeparator(self: CodeNode, sb: StringBuilder, indentation: i32, separator: string): i32 = {
    printWithSeparator(self, sb, indentation, separator, 0)
  }


  fun printWithSeparator(self: CodeNode, sb: StringBuilder, indentation: i32, separator: string, counter: i32): i32 = {
    var current = self
    var ct = counter

    match current {
      case is CodeNodeCons(head, tail) -> {
        ct = printWithSeparator(head, sb, indentation, separator, ct)
        ct = printWithSeparator(tail, sb, indentation, separator, ct)
        current = tail
      }
      else -> {
        if (ct > 0) {
          sb.append(separator)

          if (separator == "\n") {
            sb.append(src::helpers::repeat("  ", indentation))
          }
        }

        printNode(current, sb, indentation)
        ct = ct + 1
      }
    }

    ct
  }

  fun printCurlyBlock(head: CodeNode, sb: StringBuilder, indentation: i32): void = {
    val ind = src::helpers::repeat("  ", indentation)

    sb.append("{\n").append(ind).append("  ")
    printWithSeparator(head, sb, indentation + 1, "\n" ++ ind ++ "  ")
    sb.append("\n").append(ind).append("}")
  }

  fun printNode(self: CodeNode, sb: StringBuilder, indentation: i32): void = {
    val ind = src::helpers::repeat("  ", indentation)

    match self {
      case is EmptyNode() -> { /* noop */ }
      case is ErrorNode(_, desc) -> sb.append("/* ERROR: ").append(desc).append(" */")
      case is CodeNodeCons(head, tail) -> {
        printNode(head, sb, indentation)
        printNode(tail, sb, indentation)
      }
      case is Document(astNode, headDirective) -> {
        printWithSeparator(headDirective, sb, indentation, "\n" ++ ind)
      }
      case is NameIdentifierNode(astNode, name) -> sb.append(name)
      case is PrivateModifierNode -> sb.append("private ")
      case is NoModifierNode -> {/*noop*/}
      case is InjectedLiteralNode -> sb.append("%injected")
      case is QNameNode(astNode, names) -> {
        printWithSeparator(names, sb, indentation, "::")
      }
      case is FunctionTypeNode(astNode, parameters, returnType, effect) -> "FunctionTypeNode"
      case is EffectMemberDeclarationNode(astNode) -> "EffectMemberDeclarationNode"
      case is ReferenceNode(astNode, variable) -> printNode(variable, sb, indentation)
      case is BlockNode(astNode, headStatement) -> {
        printCurlyBlock(headStatement, sb, indentation)
      }
      case is MemberNode(astNode, lhs, operator, rhs) -> {
        printNode(lhs, sb, indentation)
        sb.append(operator)
        printNode(rhs, sb, indentation)
      }
      case is DecoratorNode(astNode, decoratorName, headArgument) -> {
        sb.append("#[")
        printNode(decoratorName, sb, indentation)
        if (!(headArgument is EmptyNode)) {
          sb.append(" ")
        }
        printWithSeparator(headArgument, sb, indentation, " ")
        sb.append("]")
      }
      case is ParameterNode(astNode, parameterName, parameterType) -> {
        printNode(parameterName, sb, indentation)
        if (!(parameterType is EmptyNode)) {
          sb.append(": ")
          printNode(parameterType, sb, indentation)
        }
      }
      case is FunctionNode(astNode, functionName, headParameter, returnType, body) -> {
        sb.append("fun ")
        printNode(functionName, sb, indentation)
        sb.append("(")
        printWithSeparator(headParameter, sb, indentation, ", ")
        sb.append(")")
        if (!(returnType is EmptyNode)) {
          sb.append(": ")
          printNode(returnType, sb, indentation)
        }
        if (!(body is EmptyNode)) {
          sb.append(" = ")
          match body {
            case is BlockNode -> printNode(body, sb, indentation)
            case is WasmExpressionNode -> printNode(body, sb, indentation)
            else -> printNode(body, sb, indentation + 1)
          }
        }
      }
      case is VarDeclarationNode(astNode, isMutable, name, typeDecl, value) -> {
        sb.append("var ")
        printNode(name, sb, indentation)
        if (!(typeDecl is EmptyNode)) {
          sb.append(": ")
          printNode(typeDecl, sb, indentation)
        }
        if (!(value is EmptyNode)) {
          sb.append(" = ")
          printNode(value, sb, indentation)
        }
      }
      case is AssignmentNode(astNode, lhs, rhs) -> {
        printNode(lhs, sb, indentation)
        sb.append(" = ")
        printNode(rhs, sb, indentation)
      }
      case is StructDirectiveNode(astNode, modifier, decl) -> {
        printNode(modifier, sb, indentation)
        sb.append("struct ")
        printNode(decl, sb, indentation)
      }
      case is ImplDirectiveNode(astNode, baseImpl, targetImpl, headDirective) -> {
        sb.append("impl ")
        if (!(baseImpl is EmptyNode)) {
          printNode(baseImpl, sb, indentation)
          sb.append(" for ")
        }
        printNode(targetImpl, sb, indentation)
        sb.append(" ")
        printCurlyBlock(headDirective, sb, indentation)
      }
      case is ImportDirectiveNode(astNode, module, alias) -> {
        sb.append("import ")
        printNode(module, sb, indentation)
        if (!(alias is EmptyNode)) {
          sb.append(" as ")
          printNode(alias, sb, indentation)
        }
        sb.append("\n")
      }
      case is FunDirectiveNode(astNode, headDecorator, modifier, function) -> {
        if(!(headDecorator is EmptyNode)){
          printWithSeparator(headDecorator, sb, indentation, "\n" ++ ind)
          sb.append("\n").append(ind)
        }
        printNode(modifier, sb, indentation)
        printNode(function, sb, indentation)
        sb.append("\n")
      }
      case is EffectDirectiveNode(astNode, effectDecl) -> {
        printNode(effectDecl, sb, indentation)
      }
      case is OverloadedFunDirectiveNode(astNode, functionName, headFun) -> {
        printWithSeparator(headFun, sb, indentation, "\n" ++ ind)
      }
      case is VarDirectiveNode(astNode, modifier, decl) -> {
        printNode(modifier, sb, indentation)
        printNode(decl, sb, indentation)
      }
      case is TypeDirectiveNode(astNode, modifier, name, declType) -> {
        printNode(modifier, sb, indentation)
        sb.append("type ")
        printNode(name, sb, indentation)
        if (!(declType is EmptyNode)) {
          sb.append(" = ")
          printNode(declType, sb, indentation)
        }
        sb.append("\n")
      }
      case is TraitDirectiveNode(astNode, modifier, name, headDirective) -> {
        printNode(modifier, sb, indentation)
        sb.append("trait ")
        printNode(name, sb, indentation)
        sb.append(" ")
        printCurlyBlock(headDirective, sb, indentation)
        }
      case is EnumDirectiveNode(astNode, modifier, name, headDeclaration) -> {
        printNode(modifier, sb, indentation)
        sb.append("enum ")
        printNode(name, sb, indentation)
        sb.append(" ")
        printCurlyBlock(headDeclaration, sb, indentation) 
      }
      case is NameLiteralPairNode(astNode, name, value) -> {
        printNode(name, sb, indentation)
        sb.append("=")
        printNode(value, sb, indentation)
      }

      case is FloatLiteralNode(astNode, value) -> sb.append(value)
      case is IntegerLiteralNode(astNode, value) -> sb.append(value)
      case is HexLiteralNode(astNode, value) -> sb.append(value)
      case is BooleanLiteralNode(astNode, value) -> {
        if (value == true) {
          sb.append("true")
        } else {
          sb.append("false")
        }
      }
      case is StringLiteralNode(astNode, value) -> sb.append(value)

      case is UnknownExpressionNode(astNode) -> sb.append("???")

      case is StackLiteralNode(astNode, headNames) -> {
        sb.append("%stack {")
        printWithSeparator(headNames, sb, indentation, " ")
        sb.append("}\n")
      }
      case is StructTypeNode(astNode, headParameter) -> {
        sb.append("%struct {")
        printWithSeparator(headParameter, sb, indentation, ", ")
        sb.append("}\n")
      }

      case is AbstractFunctionCallNode(astNode, headArgument, resolvedFunction) -> sb.append("%ABSTRACT FN CALL%")
      case is InjectedFunctionCallNode(astNode, headArgument, resolvedFunction) -> sb.append("%INJECTED FN CALL%")

      case is FunctionCallNode(astNode, functionNode, headArgument, resolvedFunction) -> {
        printNode(functionNode, sb, indentation)
        sb.append("(")
        printWithSeparator(headArgument, sb, indentation, ", ")
        sb.append(")")
      }

      case is ParenExpressionNode(astNode, expression) -> {
        sb.append("(")
        printNode(expression, sb, indentation)
        sb.append(")")
      }

      case is BinaryExpressionNode(astNode, lhs, operator, rhs) -> {
        printNode(lhs, sb, indentation)
        sb.append(" ")
        printNode(operator, sb, indentation)
        sb.append(" ")
        printNode(rhs, sb, indentation)
      }
      case is AsExpressionNode(astNode, lhs, rhs) -> {
        printNode(lhs, sb, indentation)
        sb.append(" as ")
        printNode(rhs, sb, indentation)
      }
      case is IsExpressionNode(astNode, lhs, rhs) -> {
        printNode(lhs, sb, indentation)
        sb.append(" is ")
        printNode(rhs, sb, indentation)
      }
      case is UnaryExpressionNode(astNode, operator, rhs) -> {
        printNode(operator, sb, indentation)
        printNode(rhs, sb, indentation)
      }
      case is WasmAtomNode(astNode, symbol, headArgument) -> {
        sb.append("(").append(symbol)
        if (!(headArgument is EmptyNode)) {
          sb.append(" ")
        }
        printWithSeparator(headArgument, sb, indentation + 1, " ")
        sb.append(")")
      }
      case is WasmExpressionNode(astNode, headAtom) -> {
        sb.append("%wasm ")
        printCurlyBlock(headAtom, sb, indentation)
      }
      case is IfNode(astNode, condition, truePart, falsePart) -> {
        sb.append("if (")
        printNode(condition, sb, indentation)
        sb.append(") ")
        match truePart {
          case is BlockNode -> printNode(truePart, sb, indentation)
          else -> printNode(truePart, sb, indentation + 1)
        }

        if (!(falsePart is EmptyNode)){
          sb.append(" else ")
          match falsePart {
            case is IfNode -> printNode(falsePart, sb, indentation)
            case is BlockNode -> printNode(falsePart, sb, indentation)
            else -> printNode(falsePart, sb, indentation + 1)
          }
        }
      }

      case is UnionTypeNode(astNode, lhs, rhs) -> {
        printNode(lhs, sb, indentation)
        sb.append(" | ")
        printNode(rhs, sb, indentation)
      }

      case is IntersectionTypeNode(astNode, lhs, rhs) -> {
        printNode(lhs, sb, indentation)
        sb.append(" & ")
        printNode(rhs, sb, indentation)
      }

      case is StructDeclarationNode(astNode, name, headParameter) -> {
        printNode(name, sb, indentation)
        sb.append("(")
        printWithSeparator(headParameter, sb, indentation + 1, ", ")
        sb.append(")")
      }
      case is EffectDeclarationNode(astNode, name) -> {
        printNode(name, sb, indentation)
      }

      case is PatternMatcherNode(astNode, lhs, headMatcher) -> {
        sb.append("match ")
        printNode(lhs, sb, indentation)
        sb.append(" ")
        printCurlyBlock(headMatcher, sb, indentation)
      }
      case is MatchConditionNode(astNode, declaredName, condition, body) -> {
        sb.append("case")
        if (!(declaredName is EmptyNode)) {
          sb.append(" ")
          printNode(declaredName, sb, indentation)
        }
        sb.append(" if ")
        printNode(condition, sb, indentation)
        sb.append(" -> ")
        printNode(body, sb, indentation + 1)
      }
      case is MatchCaseIsNode(astNode, declaredName, typeReference, headDeconstruct, body) -> {
        sb.append("case")
        if (!(declaredName is EmptyNode)) {
          sb.append(" ")
          printNode(declaredName, sb, indentation)
        }
        sb.append(" is ")
        printNode(typeReference, sb, indentation)
        if (!(headDeconstruct is EmptyNode)) {
          sb.append("(")
          printWithSeparator(headDeconstruct, sb, indentation, ", ")
          sb.append(")")
        }
        sb.append(" -> ")
        printNode(body, sb, indentation + 1)
      }
      case is MatchLiteralNode(astNode, literal, body) -> {
        sb.append("case")
        printNode(literal, sb, indentation)
        sb.append(" -> ")
        printNode(body, sb, indentation + 1)
      }
      case is MatchDefaultNode(astNode, declaredName, body) -> {
        sb.append("else")
        if (!(declaredName is EmptyNode)) {
          sb.append(" ")
          printNode(declaredName, sb, indentation)
        }
        sb.append(" -> ")
        printNode(body, sb, indentation + 1)
      }

      case is LoopNode(astNode, expression) -> {
        sb.append("loop ")
        printNode(expression, sb, indentation)
      }
      case is ContinueNode(astNode) -> sb.append("continue")
      case is BreakNode(astNode) -> sb.append("break")
      else -> support::env::printf("Dont know how to print " ++ self.nodeName())
    }
  }


  fun printAst(self: CodeNode, sb: StringBuilder, indentation: i32): void = {
    val ind = src::helpers::repeat("  ", indentation)

    match self {
      case is CodeNodeCons(head, tail) -> {
        printAst(head, sb, indentation)
        if (!(tail is EmptyNode)) {
          printAst(tail, sb, indentation)
        }
      }
      else -> {
        sb
          .append(ind)
          .append("|-")
          .append(CodeNode.nodeName(self))


        match self {
          case is NameIdentifierNode(astNode, name) -> sb.append(" name=").append(name)
          case is MemberNode(astNode, lhs, operator, rhs) -> sb.append(" operator=").append(operator)
          case is ErrorNode(astNode, desc) -> sb.append(" desc=").append(desc)
          case is FloatLiteralNode(astNode, value) -> sb.append(" value=").append(value)
          case is IntegerLiteralNode(astNode, value) -> sb.append(" value=").append(value)
          case is HexLiteralNode(astNode, value) -> sb.append(" value=").append(value)
          case is BooleanLiteralNode(astNode, value) -> sb.append(" value=").append(
            if (value) "true" else "false"
          )
          case is StringLiteralNode(astNode, value) -> sb.append(" value=").append(value)
          case is WasmAtomNode(astNode, symbol, headArgument) -> sb.append(" symbol=").append(symbol)
          else -> {
            /* noop */
            // Ok this is a bug, if a match is not a ValueNode and has no DefaultMatcher it runs the last matcher
          }
        }

        sb.append("\n")

        match self {
          case is CodeNodeCons(head, tail) -> {
            printAst(head, sb, indentation)
            printAst(tail, sb, indentation)
          }
          case is Document(astNode, headDirective) -> {
            printAst(headDirective, sb, indentation + 1)
          }
          case is FunctionTypeNode(astNode, parameters, returnType, effect) -> {
            printAst(parameters, sb, indentation + 1)
            printAst(returnType, sb, indentation + 1)
            printAst(effect, sb, indentation + 1)
          }
          case is QNameNode(astNode, names) -> {
            printAst(names, sb, indentation + 1)
          }
          case is ReferenceNode(astNode, variable) -> {
            printAst(variable, sb, indentation + 1)
          }
          case is BlockNode(astNode, headStatement) -> {
            printAst(headStatement, sb, indentation + 1)
          }
          case is MemberNode(astNode, lhs, operator, rhs) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is DecoratorNode(astNode, decoratorName, headArgument) -> {
            printAst(decoratorName, sb, indentation + 1)
            printAst(headArgument, sb, indentation + 1)
          }
          case is ParameterNode(astNode, parameterName, parameterType) -> {
            printAst(parameterName, sb, indentation + 1)
            printAst(parameterType, sb, indentation + 1)
          }
          case is FunctionNode(astNode, functionName, headParameter, returnType, body) -> {
            printAst(functionName, sb, indentation + 1)
            printAst(headParameter, sb, indentation + 1)
            printAst(returnType, sb, indentation + 1)
            printAst(body, sb, indentation + 1)
          }
          case is NameLiteralPairNode(astNode, name, value) -> {
            printAst(name, sb, indentation + 1)
            printAst(value, sb, indentation + 1)
          }
          case is StackLiteralNode(astNode, headNames) -> {
            printAst(headNames, sb, indentation + 1)
          }
          case is VarDeclarationNode(astNode, isMutable, name, typeDecl, value) -> {
            printAst(name, sb, indentation + 1)
            printAst(typeDecl, sb, indentation + 1)
            printAst(value, sb, indentation + 1)
          }
          case is AssignmentNode(astNode, lhs, rhs) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is ImplDirectiveNode(astNode, baseImpl, targetImpl, headDirective) -> {
            printAst(baseImpl, sb, indentation + 1)
            printAst(targetImpl, sb, indentation + 1)
            printAst(headDirective, sb, indentation + 1)
          }
          case is ImportDirectiveNode(astNode, module, alias) -> {
            printAst(module, sb, indentation + 1)
            printAst(alias, sb, indentation + 1)
          }
          case is StructDirectiveNode(astNode, modifier, decl) -> {
            printAst(modifier, sb, indentation + 1)
            printAst(decl, sb, indentation + 1)
          }
          case is FunDirectiveNode(astNode, headDecorator, modifier, function) -> {
            printAst(headDecorator, sb, indentation + 1)
            printAst(modifier, sb, indentation + 1)
            printAst(function, sb, indentation + 1)
          }
          case is EffectDirectiveNode(astNode, effectDecl) -> {
            printAst(effectDecl, sb, indentation + 1)
          }
          case is OverloadedFunDirectiveNode(astNode, functionName, headFun) -> {
            printAst(functionName, sb, indentation + 1)
            printAst(headFun, sb, indentation + 1)
          }
          case is VarDirectiveNode(astNode, modifier, decl) -> {
            printAst(modifier, sb, indentation + 1)
            printAst(decl, sb, indentation + 1)
          }
          case is TypeDirectiveNode(astNode, modifier, name, declType) -> {
            printAst(modifier, sb, indentation + 1)
            printAst(name, sb, indentation + 1)
            printAst(declType, sb, indentation + 1)
          }
          case is TraitDirectiveNode(astNode, modifier, name, headDirective) -> {
            printAst(modifier, sb, indentation + 1)
            printAst(name, sb, indentation + 1)
            printAst(headDirective, sb, indentation + 1)
          }
          case is EnumDirectiveNode(astNode, modifier, name, headDeclaration) -> {
            printAst(modifier, sb, indentation + 1)
            printAst(name, sb, indentation + 1)
            printAst(headDeclaration, sb, indentation + 1)
          }

          case is StructTypeNode(astNode, headParameter) -> {
            printAst(headParameter, sb, indentation + 1)
          }

          case is AbstractFunctionCallNode(astNode, headArgument, resolvedFunction) -> {
            printAst(headArgument, sb, indentation + 1)
          }
          case is InjectedFunctionCallNode(astNode, headArgument, resolvedFunction) -> {
            printAst(headArgument, sb, indentation + 1)
          }

          case is FunctionCallNode(astNode, functionNode, headArgument, resolvedFunction) -> {
            printAst(functionNode, sb, indentation + 1)
            printAst(headArgument, sb, indentation + 1)
          }

          case is ParenExpressionNode(astNode, expression) -> {
            printAst(expression, sb, indentation + 1)
          }

          case is BinaryExpressionNode(astNode, lhs, operator, rhs) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(operator, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is AsExpressionNode(astNode, lhs, rhs) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is IsExpressionNode(astNode, lhs, rhs) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is UnaryExpressionNode(astNode, operator, rhs) -> {
            printAst(operator, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is WasmAtomNode(astNode, symbol, headArgument) -> {
            printAst(headArgument, sb, indentation + 1)
          }
          case is WasmExpressionNode(astNode, headAtom) -> {
            printAst(headAtom, sb, indentation + 1)
          }
          case is IfNode(astNode, condition, truePart, falsePart) -> {
            printAst(condition, sb, indentation + 1)
            printAst(truePart, sb, indentation + 1)
            printAst(falsePart, sb, indentation + 1)
          }
          case is UnionTypeNode(astNode, lhs, rhs) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is IntersectionTypeNode(astNode, lhs, rhs) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(rhs, sb, indentation + 1)
          }
          case is StructDeclarationNode(astNode, name, headParameter) -> {
            printAst(name, sb, indentation + 1)
            printAst(headParameter, sb, indentation + 1)
          }
          case is EffectDeclarationNode(astNode, name) -> {
            printAst(name, sb, indentation + 1)
          }
          case is PatternMatcherNode(astNode, lhs, headMatcher) -> {
            printAst(lhs, sb, indentation + 1)
            printAst(headMatcher, sb, indentation + 1)
          }
          case is MatchConditionNode(astNode, declaredName, condition, body) -> {
            printAst(declaredName, sb, indentation + 1)
            printAst(condition, sb, indentation + 1)
            printAst(body, sb, indentation + 1)
          }
          case is MatchCaseIsNode(astNode, declaredName, typeReference, headDeconstruct, body) -> {
            printAst(declaredName, sb, indentation + 1)
            printAst(typeReference, sb, indentation + 1)
            printAst(headDeconstruct, sb, indentation + 1)
            printAst(body, sb, indentation + 1)
          }
          case is MatchLiteralNode(astNode, literal, body) -> {
            printAst(literal, sb, indentation + 1)
            printAst(body, sb, indentation + 1)
          }
          case is MatchDefaultNode(astNode, declaredName, body) -> {
            printAst(declaredName, sb, indentation + 1)
            printAst(body, sb, indentation + 1)
          }
          case is LoopNode(astNode, expression) -> {
            printAst(expression, sb, indentation + 1)
          }
          else -> { /* noop */ }
        }
      }
    }
  }
}
