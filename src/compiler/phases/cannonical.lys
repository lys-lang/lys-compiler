import src::lexer::tokens
import src::parser::parser
import src::compiler::nodes

fun nameOrEmpty(astNode: AstNode): NameIdentifierNode | EmptyNode =
  match processNode(astNode) {
    case name is NameIdentifierNode -> name
    else -> EmptyNode
  }

fun nameOrError(astNode: AstNode): NameIdentifierNode | ErrorNode = {
  val x = processNode(astNode)
  match x {
    case name is NameIdentifierNode -> name
    else -> ErrorNode(astNode, "A name identifier was expected, got: " ++ x.nodeName())
  }
}

fun structOrError(astNode: AstNode): StructDeclarationNode | ErrorNode = {
  val x = processNode(astNode)
  match x {
    case name is StructDeclarationNode -> name
    else -> ErrorNode(astNode, "An struct declaration was expected, got: " ++ x.nodeName())
  }
}

fun referenceOrError(astNode: AstNode): ReferenceNode | ErrorNode = {
  val x = processNode(astNode)
  match x {
    case name is ReferenceNode -> name
    else -> ErrorNode(astNode, "A reference was expected, got: " ++ x.nodeName())
  }
}

fun funOrError(astNode: AstNode): FunctionNode | ErrorNode = {
  val x = processNode(astNode)
  match x {
    case name is FunctionNode -> name
    else -> ErrorNode(astNode, "A function was expected, got: " ++ x.nodeName())
  }
}

fun fqnOrEmpty(astNode: AstNode): QNameNode | ErrorNode = {
  val x = processNode(astNode)
  match x {
    case name is QNameNode -> name
    else -> ErrorNode(astNode, "A fully qualified name was expected, got: " ++ x.nodeName())
  }
}

fun processBinaryExpression(lhs: CodeNode, astNode: AstNode): CodeNode = {
  match astNode {
    case is Node(name, child) -> {
      if (name == "Op") {
        val operator = nameOrError(first(child))
        val rhs = processNode(rest(child))
        BinaryExpressionNode(astNode, lhs, operator, rhs)
      } else if (name == "As") {
        val rhs = processNode(child)
        AsExpressionNode(astNode, lhs, rhs)
      } else if (name == "Is") {
        val rhs = processNode(child)
        IsExpressionNode(astNode, lhs, rhs)
      } else {
        BinaryExpressionNode(astNode, lhs, ErrorNode(astNode, "Error processing bin op named: " ++ name), processNode(child))
      }
    }
    case is AstCons(head, tail) -> {
      processBinaryExpression(processBinaryExpression(lhs, head), tail)
    }
    else -> {
      BinaryExpressionNode(astNode, lhs, ErrorNode(astNode, "Error processing bin op"), processNode(astNode))
    }
  }
}

fun processAtomicExpressionChild(lhs: CodeNode, astNode: AstNode): CodeNode = {
  match astNode {
    case is AstCons(head, tail) -> {
      processAtomicExpressionChild(
        processAtomicExpressionChild(lhs, head),
        tail
      )
    }
    case is Node(name, child) -> {
      match name {
        case "CallArguments" -> {
          FunctionCallNode(child, lhs, processNode(child), EmptyNode)
        }
        case "MemberExpression" -> {
          MemberNode(child, lhs, textOf(first(child)), processNode(rest(child)))
        }
        case "IndexExpression" -> {
          BinaryExpressionNode(astNode, lhs, NameIdentifierNode(child, "[]"), processNode(child))
        }
        else -> {
          // This should never happen, but you know.. we must make the type checker happy
          ErrorNode(astNode, "No handler for " ++ name)
        }
      }
    }
    else -> {
      // This should never happen, but you know.. we must make the type checker happy
      ErrorNode(astNode, "No handler for not Node nor AstCons")
    }
  }
}

fun processNode(astNode: AstNode): CodeNode = match astNode {
  case is Rule0 -> EmptyNode
  case is UnexpectedToken -> EmptyNode
  case is SyntaxError -> EmptyNode
  case is Leaf(token, value) -> processNode(astNode, token, value)
  case is AstCons(head, tail) -> CodeNodeCons(processNode(head), processNode(tail))
  case is Node(name, child) -> match name {
    case "NameIdentifier" -> processNode(child)
    case "Document" -> Document(astNode, processNode(child))
    case "PrivateModifier" -> PrivateModifierNode(astNode)
    case "NoModifier" -> NoModifierNode(astNode)
    case "ImportDirective" -> ImportDirectiveNode(astNode, fqnOrEmpty(first(child)), nameOrEmpty(second(child)))
    case "QName" -> QNameNode(astNode, processNode(child))
    case "UnionType" -> UnionTypeNode(astNode, processNode(child))
    case "IntersectionType" -> IntersectionTypeNode(astNode, processNode(child))
    case "Reference" -> ReferenceNode(astNode, fqnOrEmpty(child))
    case "MatchExpression" -> PatternMatcherNode(astNode, processNode(first(child)), processNode(rest(child)))
    case "TraitDirective" -> {
      val modifier = processNode(first(child))
      val resto = rest(child)
      TraitDirectiveNode(astNode, modifier, nameOrError(first(resto)), processNode(second(resto)))
    }
    case "NegNumberLiteral" -> FloatLiteralNode(astNode, textOf(astNode))
    case "IfExpression" -> {
      var condition = processNode(first(child))
      var truePart = processNode(second(child))
      var falsePart = processNode(third(child))
      IfNode(astNode, condition, truePart, falsePart)
    }

    case "Type" -> processNode(child)
    case "FunctionParamsList" -> processNode(child)
    case "Decorators" -> processNode(child)
    case "TraitDeclElements" -> processNode(child)
    case "TypeParameters" -> processNode(child)
    case "ReturnType" -> processNode(child)
    case "FunctionBody" -> processNode(child)
    case "FunOperator" -> NameIdentifierNode(astNode, textOf(astNode))
    case "Destructure" -> processNode(child)
    case "ReferencedType" -> processNode(child)
    case "DeclaredName" -> processNode(child)
    case "DestructureStruct" -> processNode(child)
    case "Literal" -> processNode(child)
    case "MatchBody" -> processNode(child)
    case "ContinueStatement" -> ContinueNode(astNode)
    case "BreakStatement" -> ContinueNode(astNode)
    case "LoopExpression" -> LoopNode(astNode, processNode(child))
    case "Decorator" -> DecoratorNode(astNode, nameOrError(first(child)), processNode(rest(child)))

    case "AtomicExpression" -> {
      var resto = child
      var ret = processNode(first(resto))
      resto = rest(resto)

      loop {
        val head = first(resto)
        resto = rest(resto)

        ret = processAtomicExpressionChild(ret, head)

        if (!(resto is Rule0)) {
          continue
        }
      }

      ret
    }

    case "WasmExpression" -> WasmExpressionNode(astNode, processNode(child))
    case "SExpression" -> WasmAtomNode(astNode, textOf(first(child)), processNode(rest(child)))

    case "FunctionDirective" -> {
      val decorators = processNode(first(child))
      var resto = rest(child)
      val modifier = processNode(first(resto))

      FunDirectiveNode(astNode, decorators, modifier, funOrError(second(resto)))
    }
    case "FunDeclaration" -> {
      var resto = child
      val name = nameOrError(first(resto))
      resto = rest(resto)
      val typeParameters = processNode(first(resto))
      resto = rest(resto)
      val parameters = processNode(first(resto))
      resto = rest(resto)
      val returnType = processNode(first(resto))
      resto = rest(resto)
      val body = processNode(first(resto))

      FunctionNode(astNode, name, parameters, returnType, body)
    }
    case "StructLiteral" -> StructTypeNode(astNode, processNode(child))
    case "UnaryExpression" -> UnaryExpressionNode(astNode, nameOrError(first(child)), processNode(rest(child)))
    case "Parameter" -> ParameterNode(astNode, nameOrError(first(child)), processNode(rest(child)))
    case "EnumDirective" -> {
      val modifier = processNode(first(child))
      val resto = rest(child)

      EnumDirectiveNode(astNode, modifier, nameOrError(first(resto)), processNode(rest(resto)))
    }
    case "ImplDirective" -> {
      var firstName = referenceOrError(first(child))
      var secondChild = processNode(second(child))

      match secondChild {
        case r is ReferenceNode ->
          ImplDirectiveNode(astNode, r, firstName, processNode(third(child)))
        else ->
          ImplDirectiveNode(astNode, EmptyNode, firstName, secondChild)
      }
    }
    case "InjectedLiteral" -> InjectedLiteralNode(astNode)
    case "StackLiteral" -> StackLiteralNode(astNode, processNode(child))
    case "NameLiteralPair" -> NameLiteralPairNode(astNode, nameOrError(first(child)), processNode(rest(child)))
    case "StructDirective" -> {
      val modifier = processNode(first(child))
      val resto = rest(child)
      StructDirectiveNode(astNode, modifier, structOrError(resto))
    }
    case "StructDeclaration" -> StructDeclarationNode(astNode, nameOrError(first(child)), processNode(rest(child)))
    case "BooleanLiteral" -> BooleanLiteralNode(astNode, textOf(astNode) == "true")
    case "ParenExpression" -> processNode(child)
    case "CaseCondition" -> {
      var resto = child
      val name = nameOrEmpty(first(resto))
      resto = rest(resto)
      val condition = processNode(first(resto))
      resto = rest(resto)
      val body = processNode(resto)
      MatchConditionNode(astNode, name, condition, body)
    }
    case "CaseLiteral" -> {
      val literal = processNode(first(child))
      val body = processNode(rest(child))
      MatchLiteralNode(astNode, literal, body)
    }
    case "CaseIs" -> {
      var resto = child
      val name = nameOrEmpty(first(resto))
      resto = rest(resto)
      val typeReference = processNode(first(resto))
      resto = rest(resto)
      val destructure = processNode(first(resto))
      resto = rest(resto)
      val body = processNode(resto)
      MatchCaseIsNode(astNode, name, typeReference, destructure, body)
    }
    case "CaseElse" -> {
      val name = nameOrEmpty(first(child))
      val body = processNode(rest(child))
      MatchDefaultNode(astNode, name, body)
    }
    case "AsExpression" -> processBinaryExpression(processNode(first(child)), rest(child))
    case "IsExpression" -> processBinaryExpression(processNode(first(child)), rest(child))
    case "BinaryOpExpression" -> processBinaryExpression(processNode(first(child)), rest(child))
    case "CodeBlock" -> BlockNode(astNode, processNode(child))
    case "(List)" -> processNode(child)
    case "TypeParen" -> processNode(child)
    case "TypeDirective" -> {
      val modifier = processNode(first(child))
      val resto = rest(child)
      TypeDirectiveNode(astNode, modifier, nameOrError(first(resto)), processNode(second(resto)))
    }
    case "VarDirective" -> {
      val modifier = processNode(first(child))
      val resto = rest(child)

      var decl: VarDeclarationNode | EmptyNode = EmptyNode

      match processNode(resto) {
        case x is VarDeclarationNode -> decl = x
        else -> { /* error */ }
      }

      VarDirectiveNode(astNode, modifier, decl)
    }
    case "ValDirective" -> {
      val modifier = processNode(first(child))
      val resto = rest(child)

      var decl: VarDeclarationNode | EmptyNode = EmptyNode

      match processNode(resto) {
        case x is VarDeclarationNode -> decl = x
        else -> { /* error */ }
      }

      VarDirectiveNode(astNode, modifier, decl)
    }
    case "VarDeclaration" -> {
      var name = nameOrError(first(child))

      match rest(child) {
        case is AstCons(head, tail) -> VarDeclarationNode(astNode, true, name, processNode(head), processNode(tail))
        case ast is AstNode -> VarDeclarationNode(astNode, true, name, EmptyNode, processNode(ast))
      }
    }
    case "ValDeclaration" -> {
      var name = nameOrError(first(child))

      match rest(child) {
        case is AstCons(head, tail) -> VarDeclarationNode(astNode, false, name, processNode(head), processNode(tail))
        case ast is AstNode -> VarDeclarationNode(astNode, false, name, EmptyNode, processNode(ast))
      }
    }
    else -> {
      ErrorNode(astNode, "No handler for " ++ name)
    }
  }
}


fun processNode(astNode: AstNode, node: Token, value: string): CodeNode = match node.tokenType {
  case is StringLiteral -> StringLiteralNode(astNode, value)
  case is Identifier -> NameIdentifierNode(astNode, value)
  case is Operator -> NameIdentifierNode(astNode, value)
  case is NumberLiteral -> FloatLiteralNode(astNode, value)
  case is Keyword -> match value {
    case "true" -> BooleanLiteralNode(astNode, true)
    case "false" -> BooleanLiteralNode(astNode, false)
    else -> NameIdentifierNode(astNode, value)
  }
  else -> EmptyNode
}