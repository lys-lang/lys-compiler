import src::tokens
import support::ffi

struct Parser(source: string, pos: u32)
struct None()

var instance: Parser | None = None

/**
 * Updates the parser with a string.
 */
fun instantiate(str: string): void = {
  instance = Parser(str, 0 as u32)
}

#[export "parse"]
fun parse(strAddress: UnsafeCPointer): void = instantiate(UCS2.fromPtr(strAddress))

#[export "eat"]
fun externalEat(): UnsafeCPointer = eat() as UnsafeCPointer

fun eat(): string = match instance {
  case p is Parser -> {
    val tok = p.eat()
    match tok.tokenType {
      case is EndOfFile -> "EndOfFile"
      else -> tok.tokenType.toString() ++ "(" ++ p.source.substring(tok.start as i32, tok.end as i32) ++ ")"
    }
  }
  else -> "ParserNotInitialized"
}

impl Parser {
  // Overload constructor
  fun apply(str: string): Parser = {
    Parser(str, 0 as u32)
  }

  #[method]
  fun hasNext(self: Parser): boolean = self.pos < self.source.length

  #[method]
  fun peek(self: Parser): u32 = self.source[self.pos + 1 as u32] as u32

  #[method]
  fun head(self: Parser): u32 = self.source[self.pos] as u32

  #[method]
  fun seek(self: Parser, position: u32): void = {
    self.pos = position
  }

  #[method]
  fun next(self: Parser): u32 = {
    self.pos = self.pos + 1 as u32
    self.source[self.pos] as u32
  }

  #[method]
  fun tokenStart(self: Parser, char: u32): TokenType = match char {
    case 0x09 -> Whitespace        // \t
    case 0x0A -> NewLine           // \n
    case 0x0D -> NewLine           // \r
    case 0x20 -> Whitespace        // space
    case 0x22 -> StringLiteral     // "
    case 0x23 -> MacroDecoration   // #[
    case 0x24 -> Identifier        // $
    case 0x28 -> ParenthesesOpen   // (
    case 0x29 -> ParenthesesClose  // )
    case 0x7b -> CurlyBracesOpen       // {
    case 0x7d -> CurlyBracesClose      // }
    case 0x2A -> Unknown // Operator          // *
    case 0x2F -> // '/'
      if (!self.hasNext())
        Unknown //Operator
      else match self.peek() {
        case 0x2A -> MultiLineComment
        case 0x2F -> LineComment
        else -> Unknown // Operator
      }
    case 0x5b -> VectorOpen        // [
    case 0x5d -> VectorClose       // ]
    case 0x5F -> Identifier        // _
    case 0x5F -> Identifier        // _
    case 0x5F -> Identifier        // _
    else -> {
      if (char >= 0x41 /* A */ && char <= 0x5A /* Z */) {
        Identifier
      } else if (char >= 0x61 /* a */ && char <= 0x7a /* z */) {
        Identifier
      } else {
        Unknown
      }
    }
  }

  #[method]
  fun eat(self: Parser): Token = {
    if (self.pos == self.source.length) {
      Token(EndOfFile, self.source.length, self.source.length)
    } else {
      val eaten = match self.tokenStart(self.head()) {
        case is Whitespace -> eatWhitespace(self)
        case is NewLine -> eatNewLine(self)
        case is StringLiteral -> eatString(self)
        case is Identifier -> eatIdentifier(self)
        case is MacroDecoration -> eatMacroDecoration(self)
        case is ParenthesesOpen -> eatSingleChar(self, ParenthesesOpen)
        case is ParenthesesClose -> eatSingleChar(self, ParenthesesClose)
        case is CurlyBracesOpen -> eatSingleChar(self, CurlyBracesOpen)
        case is CurlyBracesClose -> eatSingleChar(self, CurlyBracesClose)
        case is VectorOpen -> eatSingleChar(self, VectorOpen)
        case is VectorClose -> eatSingleChar(self, VectorClose)
        case is LineComment -> eatLineComment(self)
        case is MultiLineComment -> eatMultiLineComment(self)
        else -> eatUnknown(self)
      }
      self.seek(eaten.end)
      eaten
    }
  }

  private fun eatMacroDecoration(self: Parser): Token = {
    // #[
    val start = self.pos
    var end = self.pos + 1 as u32

    if (self.hasNext() && self.peek() == 0x5b) { // [
      end = end + 1 as u32
      Token(MacroDecoration, start, end)
    } else {
      Token(Unknown, start, end)
    }
  }

  private fun eatSingleChar(self: Parser, tokenType: TokenType): Token = {
    val start = self.pos
    var end = self.pos + 1 as u32
    Token(tokenType, start, end)
  }

  private fun eatWhitespace(self: Parser): Token = {
    val start = self.pos
    var end = self.pos
    val len = self.source.length
    loop {
      if (end >= len) break

      val char = self.source[end]

      if (char != 0x20)
      if (char != 0x9)
        break

      end = end + 1 as u32
      continue
    }
    Token(Whitespace, start, end)
  }

  private fun eatLineComment(self: Parser): Token = {
    val start = self.pos
    var end = self.pos
    val len = self.source.length

    loop {
      if (end >= len) break

      val char = self.source[end]

      end = end + 1 as u32

      match char {
        case 0xA -> break
        case 0xD -> break
        else -> continue
      }
    }
    Token(LineComment, start, end)
  }

  private fun eatMultiLineComment(self: Parser): Token = {
    val start = self.pos
    var end = self.pos
    val len = self.source.length

    loop {
      if (end >= len) break

      val char = self.source[end]

      end = end + 1 as u32

      if (char == 0x2A) { // '*'
        if (end < len) {
          val next = self.source[end]
          if (next == 0x2F){ // '/'
            end = end + 1 as u32
            break
          }
        }
      }

      continue
    }

    Token(MultiLineComment, start, end)
  }

  private fun eatUnknown(self: Parser): Token = {
    val start = self.pos
    var end = self.pos
    val len = self.source.length
    loop {
      if (end >= len) break

      val char = self.source[end] as u32

      match self.tokenStart(char) {
        case is Unknown -> {
          end = end + 1 as u32
          continue
        }
        else -> break
      }
    }
    Token(Unknown, start, end)
  }

  private fun eatString(self: Parser): Token = {
    val start = self.pos
    var end = self.pos
    val len = self.source.length
    loop {
      if (end >= len) break

      if (self.source[end] == 0x22 && start != end) {
        end = end + 1 as u32
        break
      }

      end = end + 1 as u32
      continue
    }
    Token(StringLiteral, start, end)
  }

  private fun eatNewLine(self: Parser): Token = {
    val start = self.pos
    var end = self.pos
    val len = self.source.length
    loop {
      if (end >= len) break

      val char = self.source[end]

      if (char != 0xA)
      if (char != 0xD)
        break

      end = end + 1 as u32
      continue
    }
    Token(NewLine, start, end)
  }

  private fun eatIdentifier(self: Parser): Token = {
    // '$'? [A-Za-z_]([A-Za-z0-9_$])*
    val start = self.pos
    var end = self.pos
    val len = self.source.length

    // TODO: Validate first char

    loop { // [A-Za-z0-9_$]
      if (end >= len) break

      val char = self.source[end] as u32

      if (char != 0x24) // $
      if (char != 0x5F) // _
      if (char < 0x41 || char > 0x5A) // A-Z
      if (char < 0x61 || char > 0x7a) // a-z
      if (char < 0x30 || char > 0x39) // 0-9
        break

      end = end + 1 as u32
      continue
    }
    Token(Identifier, start, end)
  }
}
