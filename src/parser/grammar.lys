import src::lexer::tokens
import src::helpers

// Parsing rules definitions

enum ParserRule {
  Terminal(tokenType: TokenType)
  StrictTerminal(tokenType: TokenType, value: string)
  NonTerminal(name: string)
  Or(lhs: ParserRule, rhs: ParserRule)
  OneOrMore(rule: ParserRule)
  ZeroOrMore(rule: ParserRule)
  Cons(head: ParserRule, tail: ParserRule)
  Cut(head: ParserRule, tail: ParserRule)
  Optional(rule: ParserRule)
  Fail(message: string)
  LookAhead(rule: ParserRule)
  Discard(rule: ParserRule)
}

impl ParserRule {
  #[method]
  fun toString(self: ParserRule): string = match self {
    case is Terminal(tokenType) -> "<" ++ tokenType.toString() ++ ">"
    case is StrictTerminal(tokenType, value) -> "\"" ++ value ++ "\""
    case is NonTerminal(name) -> name

    case is Or(lhs, rhs) -> "or(" ++ lhs.toString() ++ ", " ++ rhs.toString() ++ ")"
    case is Cons(head, tail) -> "cons(" ++ head.toString() ++ ", " ++ tail.toString() ++ ")"
    case is Cut(head, tail) -> "cut(" ++ head.toString() ++ ", " ++ tail.toString() ++ ")"

    case is OneOrMore(rule) -> "oneOrMore(" ++ rule.toString() ++ ")"
    case is ZeroOrMore(rule) -> "zeroOrMore(" ++ rule.toString() ++ ")"
    case is Optional(rule) -> "optional(" ++ rule.toString() ++ ")"

    case is Fail(message) -> "fail(`" ++ message ++ "`)"
    case is LookAhead(rule) -> "ahead(" ++ rule.toString() ++ ")"
    case is Discard(rule) -> "discard(" ++ rule.toString() ++ ")"
  }
}

// Grammar definitions

enum Grammar {
  Nominal(name: string, rule: ParserRule)
  GrammarConj(tail: Grammar, head: Nominal)
}

impl Grammar {
  fun ++(tail: Grammar, head: Nominal): Grammar = GrammarConj(tail, head)

  #[method]
  fun toString(self: Grammar): string = match self {
    case is Nominal(name, rule) -> name ++ "\t ::= " ++ ParserRule.toString(rule)
    case is GrammarConj(head, tail) -> Grammar.toString(tail) ++ "\n" ++ Grammar.toString(head)
  }

  #[method]
  fun findRule(self: Grammar, ruleName: string): ParserRule | Nil = {
    match self {
      case is Nominal(name, rule) -> if (name == ruleName) rule else Nil
      case is GrammarConj(tail, head) ->
        if (head.name == ruleName)
          head.rule
        else
          tail.findRule(ruleName)
    }
  }
}

impl Nominal {
  fun ++(lhs: Grammar, rhs: Nominal): Grammar = GrammarConj(lhs, rhs)
}

