import src::helpers
import src::lexer::tokens
import src::lexer::lexer
import src::parser::grammar

// AST definitions

enum AstNode {
  Leaf(name: string, token: Token, value: string)
  Branch(name: string, child: AstNode | Nil)
  OptionalNode(child: AstNode | Nil)
  AstCons(head: AstNode, tail: AstNode)
}

fun printAst(ast: AstNode | Nil, level: i32): string = match ast {
  case is Nil -> "<EMPTY>"
  case is Branch(name, child) ->
    repeat("  ", level) ++ "|-" ++ name ++ "\n" ++ printAst(child, level + 1)
  case is OptionalNode(child) -> printAst(child, level)
  case is Leaf(name, token, value) ->
    repeat("  ", level) ++ "|-" ++ name ++ "=" ++ value
  case is AstCons(head, tail) ->
    printAst(head, level) ++ "\n" ++ printAst(tail, level)
}

// Parser definitions

struct Parser(lexer: Lexer, grammar: Grammar)

fun parse(source: string, rule: string, grammar: Grammar): AstNode | Nil = {
  parse(rule, Parser(Lexer(source), grammar), 0)
}

fun parse(ruleName: string, parser: Parser, level: i32): AstNode | Nil = {
  match parser.grammar.findRule(ruleName) {
    case rule is ParserRule -> match parse(rule, ruleName, parser, level) {
      case is Nil -> Nil
      case ast is AstNode -> Branch(ruleName, ast)
    }
    else -> {
      support::env::printf("MISSING RULE " ++ ruleName ++ "!")
      Nil
    }
  }
}

fun parse(rule: ParserRule, ruleName: string, parser: Parser, level: i32): AstNode | Nil = {
  var backtrack = parser.lexer.pos

  val result = match rule {
    case is Terminal(tokenType) -> {
      support::env::printf(repeat("| ", level) ++ "| Terminal(" ++ TokenType.toString(tokenType) ++ ")")
      support::env::printf(repeat("| ", level) ++ "|   from:" ++ parser.lexer.source.substring(parser.lexer.pos as i32))
      val lexer = parser.lexer
      val token = lexer.peek()
      if (token.tokenType == tokenType)
        Leaf(ruleName, lexer.eat(), token.textIn(lexer.source))
      else
        Nil
    }
    case is StrictTerminal(tokenType, value) -> {
      support::env::printf(repeat("| ", level) ++ "| StrictTerminal(" ++ TokenType.toString(tokenType) ++ ")")
      support::env::printf(repeat("| ", level) ++ "|   from:" ++ parser.lexer.source.substring(parser.lexer.pos as i32))
      val lexer = parser.lexer
      val token = lexer.peek()
      val tokenValue = token.textIn(lexer.source)
      if (token.tokenType == tokenType && value == tokenValue)
        Leaf(ruleName, lexer.eat(), tokenValue)
      else
        Nil
    }
    case is Or(lhs, rhs) -> {
      support::env::printf(repeat("| ", level) ++ "| Or")
      match parse(lhs, ruleName, parser, level + 1) {
        case is Nil -> parse(rhs, ruleName, parser, level + 1)
        case ast is AstNode -> ast
      }
    }
    case is Cons(head, tail) -> {
      support::env::printf(repeat("| ", level) ++ "| Cons")
      match parse(head, ruleName, parser, level + 1) {
        case is Nil -> Nil
        case astHead is AstNode -> match parse(tail, ruleName, parser, level + 1) {
          case is Nil -> Nil
          case astTail is AstNode -> AstCons(astHead, astTail)
        }
      }
    }
    case is Optional(rule) -> {
      support::env::printf(repeat("| ", level) ++ "| Optional")
      OptionalNode(parse(rule, ruleName, parser, level + 1))
    }
    case is NonTerminal(name) -> {
      support::env::printf(repeat("| ", level) ++ "| NonTerminal("++name++")")
      parse(name, parser, level + 1)
    }
    case is OneOrMore(rule) -> {
      support::env::printf(repeat("| ", level) ++ "| OneOrMore")
      var ret: AstNode | Nil = Nil

      loop {
        match parse(rule, ruleName, parser, level + 1) {
          case is Nil -> break
          case ast is AstNode -> {
            match ret {
              case is Nil -> ret = ast
              case x is AstNode -> ret = AstCons(x, ast)
            }
            continue
          }
        }
      }

      ret
    }
    case is ZeroOrMore(rule) -> {
      support::env::printf(repeat("| ", level) ++ "| ZeroOrMore")
      var ret: AstNode | Nil = Nil

      loop {
        match parse(rule, ruleName, parser, level + 1) {
          case is Nil -> break
          case ast is AstNode -> {
            match ret {
              case is Nil -> ret = ast
              case x is AstNode -> ret = AstCons(x, ast)
            }
            continue
          }
        }
      }

      OptionalNode(ret)
    }
  }

  if (result is Nil) {
    parser.lexer.pos = backtrack
    support::env::printf(repeat("| ", level) ++ "|<- backtracking")
  }

  result
}