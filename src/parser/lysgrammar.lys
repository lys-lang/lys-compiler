import src::helpers
import src::lexer::lexer
import src::lexer::tokens
import src::parser::grammar
import src::parser::parser

/*
  Terminal(tokenType: TokenType)
  StrictTerminal(tokenType: TokenType, value: string)
  NonTerminal(name: string)
  Or(lhs: ParserRule, rhs: ParserRule)
  OneOrMore(rule: ParserRule)
  ZeroOrMore(rule: ParserRule)
  Cons(head: ParserRule, tail: ParserRule)
  Cut(head: ParserRule, tail: ParserRule)
  Optional(rule: ParserRule)
  Fail(message: string)
  LookAhead(rule: ParserRule)
  Discard(rule: ParserRule)
*/

private var grammar: Nil | Grammar = Nil

// n == named
fun n(name: string): ParserRule = NonTerminal(name)

// t == Identifier
fun t(name: string): ParserRule = StrictTerminal(Identifier, name)

// op == Operator
fun op(name: string): ParserRule = StrictTerminal(Operator, name)

fun Wrap(start: TokenType, middle: ParserRule, end: TokenType): ParserRule =
  WrapWith(Terminal(start), middle, Terminal(end))

fun WrapWith(start: ParserRule, middle: ParserRule, end: ParserRule): ParserRule =
  Cut(Cut(Discard(start), middle), Discard(end))

fun Rune(start: ParserRule, middle: ParserRule, message: string): ParserRule =
  Cut(start, Or(middle, Fail(message)))

fun OneOrMoreComma(rule: ParserRule): ParserRule =
  Cons(
    Optional(n("WS")),
    Cut(rule, Optional(n("WS"))),
    ZeroOrMore(
      Cut(
        Discard(Terminal(Comma)),
        Optional(n("WS")),
        rule
      )
    ),
    Optional(n("WS"))
  )

fun getGrammar(): Grammar = {
  match grammar {
    case g is Grammar -> g
    else -> {
      val WS = Discard(Optional(n("WS")))
      val NEW_LINE = Discard(
        Cons(
          ZeroOrMore(Or(Terminal(Whitespace), Terminal(MultiLineComment))),
          Or(Terminal(NewLine), Terminal(LineComment))
        )
      )
      val WSS = Discard(n("WS"))

      val g =
        Nominal("Document", Push("Document", Cut(Cons(WS, OneOrMore(Cut(n("Directive"), WS))), Terminal(EndOfFile)))) ++
        Nominal("WS",
          Discard(
            OneOrMore(
              Or(
                Terminal(Whitespace),
                Terminal(LineComment),
                Terminal(MultiLineComment),
                Terminal(NewLine)
              )
            )
          )
        ) ++

        Nominal("Directive",
          Or(n("FunctionDirective"),
          Or(n("ValDirective"),
          Or(n("VarDirective"),
          Or(n("StructDirective"),
          Or(n("TypeDirective"),
          Or(n("EnumDirective"),
          Or(n("TraitDirective"),
          Or(n("ImportDirective"),
          Or(n("EffectDirective"), n("ImplDirective"))))))))))
        ) ++

        Nominal("ImplInnerDirective",
          Or(n("FunctionDirective"), n("ValDirective"), n("VarDirective"))
        ) ++

        Nominal("PrivateModifier", Push("PrivateModifier", n("PRIVATE_KEYWORD"))) ++

        Nominal("ImportDirective", Push("ImportDirective",
          Cut(
            n("IMPORT_KEYWORD"),
            Cut(
              n("QName"),
              Optional(
                Cut(Cons(WSS, n("AsKeyword")), n("NameIdentifier"))
              )
            )
          )
        )) ++
        Nominal("FunctionDirective", Push("FunctionDirective",
          Cons(
            Cons(
              n("Decorators"),
              Optional(n("PrivateModifier"))
            ),
            n("FunDeclaration")
          )
        )) ++
        Nominal("ValDirective", Push("ValDirective",
          Cons(
            Optional(n("PrivateModifier")), n("ValDeclaration")
          )
        )) ++
        Nominal("VarDirective", Push("VarDirective",
          Cons(
            Optional(n("PrivateModifier")), n("VarDeclaration")
          )
        )) ++
        Nominal("TypeDirective", Push("TypeDirective",
          Cons(
            Optional(n("PrivateModifier")),
            Cut(n("TYPE_KEYWORD"), n("NameIdentifier")),
            WS,
            Optional(n("ValueType"))
          )
        )) ++
        Nominal("EnumDirective", Push("EnumDirective",
          Cons(
            Optional(n("PrivateModifier")),
            Cut(n("ENUM_KEYWORD"), n("NameIdentifier")),
            WS,
            Wrap(CurlyBracesOpen, Cons(WS, Optional(n("TypeDeclElements")), WS), CurlyBracesClose)
          )
        )) ++
        Nominal("TraitDirective", Push("TraitDirective",
          Cons(
            Optional(n("PrivateModifier")),
            Cut(
              n("TRAIT_KEYWORD"),
              n("NameIdentifier")
            ),
            WS,
            Wrap(CurlyBracesOpen, Cons(WS, Optional(n("TraitDeclElements")), WS), CurlyBracesClose)
          )
        )) ++
        Nominal("EffectDirective", Push("EffectDirective",
          Cons(
            Optional(n("PrivateModifier")),
            Cut(
              n("EFFECT_KEYWORD"),
              n("EffectDeclaration")
            )
          )
        )) ++
        Nominal("StructDirective", Push("StructDirective",
          Cons(
            Optional(n("PrivateModifier")),
            Cut(
              n("STRUCT_KEYWORD"),
              n("StructDeclaration")
            )
          )
        )) ++
        Nominal("ImplDirective", Push("ImplDirective",
          Cons(
            Optional(n("PrivateModifier")),
            Cut(n("IMPL_KEYWORD"), n("Reference")),
            WS,
            Optional(
              Cons(t("FOR_KEYWORD"), n("Reference"), WS)
            ),
            n("NamespaceElementList")
          )
        )) ++
        Nominal("Decorators", Push("Decorators", ZeroOrMore(n("Decorator")))) ++
        Nominal("Decorator", Push("Decorator", Cons(Wrap(MacroDecoration, Cons(WS, n("NameIdentifier"), ZeroOrMore(Cons(WSS, n("Literal"))), WS), VectorClose), WS))) ++
        Nominal("LoopExpression", Push("LoopExpression", Cut(Discard(t("loop")), WS, n("Expression")))) ++
        Nominal("ContinueStatement", Push("ContinueStatement", t("continue"))) ++
        Nominal("BreakStatement", Push("BreakStatement", t("break"))) ++
        Nominal("ValDeclaration", Push("ValDeclaration", Cons(Cut(Discard(t("val")), WS, n("NameIdentifier")), Optional(n("OfType")), WS, n("Assign")))) ++
        Nominal("VarDeclaration", Push("VarDeclaration", Cons(Cut(Discard(t("var")), WS, n("NameIdentifier")), Optional(n("OfType")), WS, n("Assign")))) ++
        Nominal("FunDeclaration", Push("FunDeclaration", Cons(Cut(Discard(t("fun")), WS, n("FunctionName")), WS, Optional(n("TypeParameters")), n("FunctionParamsList"), WS, Optional(n("OfType")),WS, Optional(n("FunAssignExpression"))))) ++
        Nominal("MatchExpression", Push("MatchExpression", Cons(Cut(Discard(t("match")), WS), n("AssignExpression"), WS, n("MatchBody")))) ++
        Nominal("CaseCondition", Push("CaseCondition", Cons(Discard(t("case")), WS, n("NameIdentifier"), WSS, Cut(t("if"), WS, n("Expression"), WS, op("->")), WS, n("Expression")))) ++
        Nominal("CaseLiteral", Push("CaseLiteral", Cons(Discard(t("case")), WS, Cut(n("Literal"), WS, op("->"), WS, n("Expression"))))) ++
        Nominal("CaseIs", Push("CaseIs", Cons(Discard(t("case")), WS, Optional(Cons(n("NameIdentifier"), WSS)), Cut(t("is"), WSS, n("Reference")), WS, Optional(n("DeconstructStruct")), op("->"), WS, n("Expression")))) ++
        Nominal("CaseElse", Push("CaseElse", Cons(Cut(Discard(t("else")), WS), Optional(Cut(n("NameIdentifier"), WSS)), op("->"), WS, n("Expression")))) ++
        Nominal("IfExpression", Push("IfExpression", Cons(Cut(Discard(t("if")), WS), n("IfBody"), WS, n("Expression"), Optional(Cons(WS, n("ElseExpression")))))) ++
        Nominal("ElseExpression", Cons(Cut(Discard(t("else")), WS), n("Expression"))) ++
        Nominal("WasmExpression", Push("WasmExpression", Cut(Cons(op("%"), t("wasm")), WS,
          Wrap(CurlyBracesOpen, Cons(WS, ZeroOrMore(n("SAtom")), WS), CurlyBracesClose), WS
        ))) ++
        Nominal("StructLiteral", Push("StructLiteral", Cut(Cons(op("%"), t("struct")), WS, n("StructParamsList")))) ++
        Nominal("InjectedLiteral", Push("InjectedLiteral", Cons(op("%"), t("injected")))) ++
        Nominal("StackLiteral", Push("StackLiteral",
          Cut(
            Cons(op("%"), t("stack")),
            Cons(
              WS,
              Wrap(CurlyBracesOpen, Cons(WS, ZeroOrMore(Cons(n("NameLiteralPair"), WS))), CurlyBracesClose),
              WS
            )
          )
        )) ++

        Nominal("IfBody", Push("IfBody", Wrap(ParenthesesOpen, Cons(WS, n("Expression"), WS), ParenthesesClose))) ++
        Nominal("MatchElements", Cut(Or(n("CaseCondition"), n("CaseIs"), n("CaseLiteral"), n("CaseElse")), WS)) ++

        Nominal("UnknownExpression", Push("UnknownExpression", t("???"))) ++
        Nominal("ValueType", Push("ValueType",
          Cut(
            Cons(t("="), WS),
            Or(
              Cons(LookAhead(op("%")), Or(n("InjectedLiteral"), n("StructLiteral"), n("StackLiteral"))),
              n("Type")
            )
          )
        )) ++

        Nominal("TypeVariableList", Push("TypeVariableList", Cons(n("TypeVariable"), ZeroOrMore(Cut(Terminal(Comma), WS, n("TypeVariable") , WS)), WS))) ++
        Nominal("TypeVariable", Push("TypeVariable", n("NameIdentifier"))) ++
        Nominal("TypeParameters", Push("TypeParameters", Cons(WrapWith(op("<"), Cons(WS, Optional(n("TypeVariableList"))), op(">")), WS))) ++

        Nominal("Assign", Rune(Cons(op("="), WS), Or(n("Expression"), n("UnknownExpression")), "A value was expected.")) ++
        Nominal("FunAssignExpression", Push("FunAssignExpression", Cut(op("="), WS, Or(n("Expression"), n("WasmExpression"), n("UnknownExpression"))))) ++
        Nominal("OfType", Push("OfType", Rune(Cons(op(":"), WS), Cons(Optional(Cons(n("FunctionEffect"), WS)), n("Type"), WS), "A type was expected"))) ++

        Nominal("StructParamsList", Push("StructParamsList", Wrap(CurlyBracesOpen, Cons(WS, n("ParameterList"), WS), CurlyBracesClose))) ++
        Nominal("FunctionParamsList", Push("FunctionParamsList", Wrap(ParenthesesOpen, Cons(WS, n("ParameterList"), WS), ParenthesesClose))) ++
        Nominal("ParameterList", Push("ParameterList", Optional(OneOrMoreComma(n("Parameter"))))) ++
        Nominal("Parameter", Push("Parameter", Cut(n("NameIdentifier"), WS, Optional(n("OfType")), WS))) ++

        Nominal("StructDeclaration", Push("StructDeclaration", Cons(Cut(n("NameIdentifier"), WS), Optional(n("FunctionParamsList"))))) ++
        Nominal("EffectMemberDeclaration", Push("EffectMemberDeclaration", Cut(n("NameIdentifier"), WS, n("FunctionParamsList"), n("OfType")))) ++
        Nominal("TraitDeclElements", Push("TraitDeclElements", OneOrMore(Cons(WS, n("FunctionDirective"))))) ++
        Nominal("TypeDeclElements", Push("TypeDeclElements", OneOrMore(Cons(WS, n("StructDeclaration"))))) ++
        Nominal("EffectElements", Push("EffectElements", OneOrMore(Cons(WS, n("EffectMemberDeclaration"))))) ++

        Nominal("FunctionName", Push("FunctionName",  Or(n("NameIdentifier"), n("FunOperator")))) ++

        Nominal("FunOperator", Push("FunOperator", Or(n("BitNotPreOperator"), n("MinusPreOperator"),
                                  n("AsKeyword"),
                                  n("IsKeyword"),
                                  n("MulOperator"),
                                  Or(n("AddOperator"),
                                    n("ShiftOperator"),
                                    n("RelOperator"),
                                    n("EqOperator")),
                                  Or(n("BitAndOperator"),
                                    n("BitXorOperator"),
                                    n("BitOrOperator"),
                                    n("AndKeyword"),
                                    n("OrKeyword"),
                                    n("NotPreOperator"),
                                    Cut(op("["), op("]"))
                                  )
                              ))) ++

        Nominal("NamespaceElementList", Push("NamespaceElementList",
          Wrap(CurlyBracesOpen, Cons(WS, ZeroOrMore(Cons(n("ImplInnerDirective"), WS))), CurlyBracesClose))
        ) ++
        Nominal("EffectDeclaration", Push("EffectDeclaration", Cut(n("NameIdentifier"), WS, Optional(n("TypeParameters")), n("EffectElementList")))) ++
        Nominal("EffectElementList", Push("EffectElementList", Wrap(CurlyBracesOpen, Cons(WS, Optional(n("EffectElements")), WS), CurlyBracesClose))) ++
        Nominal("FunctionEffect", Push("FunctionEffect", WrapWith(op("<"), Cons(WS, Optional(Cons(n("Type"), WS))), op(">")))) ++

        Nominal("Type", Push("Type", n("UnionType"))) ++
        Nominal("UnionType", PushIfManyChildren("UnionType", Cut(n("IntersectionType"), ZeroOrMore(Cons(WS, op("|"), WS, n("IntersectionType")))))) ++
        Nominal("IntersectionType", PushIfManyChildren("IntersectionType", Cut(n("AtomType"), ZeroOrMore(Cons(WS, op("&"), WS, n("AtomType")))))) ++
        Nominal("AtomType", Or(n("TypeParen"), n("FunctionTypeLiteral"), n("Reference"))) ++
        Nominal("TypeParen", Push("TypeParen", Wrap(ParenthesesOpen, Cut(WS, n("Type"), WS), ParenthesesClose))) ++

        Nominal("FunctionTypeLiteral", Push("FunctionTypeLiteral", Cut(Cons(t("fun"), WS), Cons(Optional(n("TypeParameters")), n("FunctionTypeParameters"), WS, op("->"), WS, n("Type"))))) ++
        Nominal("FunctionTypeParameters", Push("FunctionTypeParameters", Wrap(ParenthesesOpen, Optional(OneOrMoreComma(n("FunctionTypeParameter"))), ParenthesesClose))) ++ // {pin=1,recoverUntil=PAREN_RECOVERY}
        Nominal("FunctionTypeParameter", Push("FunctionTypeParameter", Cons(Optional(Cons(n("NameIdentifier"), WS, op(":"))), WS, n("Type")))) ++

        Nominal("Expression",Or(n("IfExpression"),
                                n("MatchExpression"),
                                n("LoopExpression"),
                                n("BreakStatement"),
                                n("ContinueStatement"),
                                n("AssignExpression"))) ++
        Nominal("Statement", Or(n("ValDeclaration"),
                                n("VarDeclaration"),
                                n("FunDeclaration"),
                                n("Expression"))) ++

        Nominal("AssignExpression", PushIfManyChildren("AssignExpression", Cons(n("OrExpression"), ZeroOrMore(Cons(WS, n("AssignmentKeyword"), WS, n("OrExpression")))))) ++
        Nominal("OrExpression", PushIfManyChildren("OrExpression", Cons(n("AndExpression"), ZeroOrMore(Cons(WS, n("OrKeyword"), WS, n("AndExpression")))))) ++
        Nominal("AndExpression", PushIfManyChildren("AndExpression", Cons(n("BitOrExpression"), ZeroOrMore(Cons(WS, n("AndKeyword"), WS, n("BitOrExpression")))))) ++
        Nominal("BitOrExpression", PushIfManyChildren("BitOrExpression", Cons(n("BitXorExpression"), ZeroOrMore(Cons(WS, n("BitOrOperator"), WS, n("BitXorExpression")))))) ++
        Nominal("BitXorExpression", PushIfManyChildren("BitXorExpression", Cons(n("BitAndExpression"), ZeroOrMore(Cons(WS, n("BitXorOperator"), WS, n("BitAndExpression")))))) ++
        Nominal("BitAndExpression", PushIfManyChildren("BitAndExpression", Cons(n("EqExpression"), ZeroOrMore(Cons(WS, n("BitAndOperator"), WS, n("EqExpression")))))) ++
        Nominal("EqExpression", PushIfManyChildren("EqExpression", Cons(n("RelExpression"), ZeroOrMore(Cons(WS, n("EqOperator"), WS, n("RelExpression")))))) ++
        Nominal("RelExpression", PushIfManyChildren("RelExpression", Cons(n("ShiftExpression"), ZeroOrMore(Cons(WS, n("RelOperator"), WS, n("ShiftExpression")))))) ++
        Nominal("ShiftExpression", PushIfManyChildren("ShiftExpression", Cons(n("AddExpression"), ZeroOrMore(Cons(WS, n("ShiftOperator"), WS, n("AddExpression")))))) ++
        Nominal("AddExpression", PushIfManyChildren("AddExpression", Cons(n("MulExpression"), ZeroOrMore(Cons(WS, n("AddOperator"), WS, n("MulExpression")))))) ++
        Nominal("MulExpression", PushIfManyChildren("MulExpression", Cons(n("IsExpression"), ZeroOrMore(Cons(WS, n("MulOperator"), WS, n("IsExpression")))))) ++
        Nominal("IsExpression", PushIfManyChildren("IsExpression", Cons(n("AsExpression"), ZeroOrMore(Cons(WS, n("IsKeyword"), WS, n("Type")))))) ++
        Nominal("AsExpression", PushIfManyChildren("AsExpression", Cons(n("UnaryExpression"), ZeroOrMore(Cons(WS, n("AsKeyword"), WS, n("Type")))))) ++
        Nominal("UnaryExpression", PushIfManyChildren("UnaryExpression", Or(n("NegExpression"),
                                      n("BinNegExpression"),
                                      n("UnaryMinus"),
                                      n("AtomicExpression")))) ++
        Nominal("AtomicExpression", PushIfManyChildren("AtomicExpression", Cut(n("Value"), ZeroOrMore(Cons(WS, Or(n("MemberExpression"), n("CallArguments"), n("IndexExpression"))))))) ++

        Nominal("BinMemberOperator", Push("BinMemberOperator",  Or(op(".^"), op(".")))) ++
        Nominal("MemberExpression", Push("MemberExpression",  Cut(n("BinMemberOperator"), n("NameIdentifier")))) ++
        Nominal("IndexExpression", Push("IndexExpression",  Wrap(VectorOpen, Cons(WS, n("Expression"), WS), VectorClose))) ++

        Nominal("NegExpression", Push("NegExpression", Cut(op("!"), n("AtomicExpression")))) ++
        Nominal("BinNegExpression", Push("BinNegExpression", Cut(op("~"), n("AtomicExpression")))) ++
        Nominal("UnaryMinus", Push("UnaryMinus", Cons(op("-"), n("AtomicExpression")))) ++

        Nominal("Value", Or(n("Literal"),
                            n("Reference"),
                            n("ParenExpression"),
                            n("CodeBlock"))) ++

        Nominal("ParenExpression", Push("ParenExpression", Wrap(ParenthesesOpen, Cons(WS, n("Expression"), WS), ParenthesesClose))) ++

        Nominal("CodeBlock", Push("CodeBlock",
          Wrap(
            CurlyBracesOpen,
            Cons(WS,
              Optional(
                Cut(
                  n("Statement"), ZeroOrMore(
                    Cons(NEW_LINE, WS, n("Statement"))))), WS), CurlyBracesClose))) ++

        // Pattern matching
        Nominal("MatchBody", Push("MatchBody", Wrap(CurlyBracesOpen, Cons(WS, ZeroOrMore(n("MatchElements"))), CurlyBracesClose))) ++

        Nominal("DeconstructStruct", Push("DeconstructStruct", Cons(Wrap(ParenthesesOpen, Optional(OneOrMoreComma(n("NameIdentifier"))), ParenthesesClose), WS))) ++

        // Function call
        Nominal("CallArguments", Push("CallArguments",  Wrap(ParenthesesOpen, Optional(OneOrMoreComma(n("Expression"))), ParenthesesClose))) ++

        Nominal("Reference", Push("Reference", n("QName"))) ++

        Nominal("BooleanLiteral", Push("BooleanLiteral", Or(t("true"), t("false")))) ++
        Nominal("PostfixNumber", PushIfManyChildren("PostfixNumber", Cut(Terminal(NumberLiteral), Optional(n("Reference"))))) ++
        Nominal("NegNumberLiteral", Push("NegNumberLiteral", Cons(Optional(op("-")), Terminal(NumberLiteral)))) ++

        Nominal("Literal", Or(Terminal(StringLiteral), n("PostfixNumber"), n("BooleanLiteral"))) ++

        Nominal("NameIdentifier", Push("NameIdentifier", Cons(NegativeLookAhead(n("KEYWORD")), Terminal(Identifier)))) ++
        Nominal("QName", Push("QName", Cut(n("NameIdentifier"), ZeroOrMore(Cut(op("::"), n("NameIdentifier")))))) ++

        Nominal("NameLiteralPair", Push("NameLiteralPair", Cut(n("NameIdentifier"), WS, op("="), WS, n("Literal")))) ++

        Nominal("SExpression", Push("SExpression", Cons(Wrap(ParenthesesOpen, Cons(WS, n("SSymbol"), WS, ZeroOrMore(n("SAtom")), WS), ParenthesesClose), WS))) ++
        Nominal("SAtom", Cons(Or(n("QName"),
                                 n("SExpression"),
                                 n("NegNumberLiteral")), WS)) ++

        Nominal("SSymbol", Push("SSymbol", Cut(Terminal(Identifier), ZeroOrMore(Or(Terminal(Identifier), op("/"), op(".")))))) ++

        // Keywords

        Nominal("KEYWORD", Or(Or(
                                t("true"),
                                t("false"),
                                t("if"),
                                t("else"),
                                t("case")),
                              Or(
                                n("VAR_KEYWORD"),
                                n("VAL_KEYWORD"),
                                n("TYPE_KEYWORD")),
                              Or(
                                n("ENUM_KEYWORD"),
                                n("TRAIT_KEYWORD"),
                                n("EFFECT_KEYWORD"),
                                n("IMPL_KEYWORD"),
                                n("FOR_KEYWORD"),
                              Or(
                                n("IMPORT_KEYWORD"),
                                n("FUN_KEYWORD")),
                                n("STRUCT_KEYWORD"),
                                n("PRIVATE_KEYWORD"),
                                n("MATCH_KEYWORD")),
                              Or(
                                t("loop"),
                                t("continue"),
                                t("break"),
                                n("RESERVED_WORDS")))) ++

        Nominal("FUN_KEYWORD", Cut(t("fun"), WSS)) ++
        Nominal("VAL_KEYWORD", Cut(t("val"), WSS)) ++
        Nominal("VAR_KEYWORD", Cut(t("var"), WSS)) ++
        Nominal("EFFECT_KEYWORD", Cut(t("effect"), WSS)) ++
        Nominal("IMPL_KEYWORD", Cut(t("impl"), WSS)) ++
        Nominal("FOR_KEYWORD", Cut(t("for"), WSS)) ++
        Nominal("IMPORT_KEYWORD", Cut(t("import"), WSS)) ++
        Nominal("STRUCT_KEYWORD", Cut(t("struct"), WSS)) ++
        Nominal("PRIVATE_KEYWORD", Cut(t("private"), WSS)) ++
        Nominal("TYPE_KEYWORD", Cut(t("type"), WSS)) ++
        Nominal("ENUM_KEYWORD", Cut(t("enum"), WSS)) ++
        Nominal("TRAIT_KEYWORD", Cut(t("trait"), WSS)) ++
        Nominal("MATCH_KEYWORD", Cut(t("match"), WSS)) ++

        Nominal("RESERVED_WORDS",  Or(Or(t("abstract"),
                                        t("async"),
                                        t("await"),
                                        t("class"),
                                        t("const"),
                                        t("declare")),
                                      Or(t("defer"),
                                        t("delete"),
                                        t("do"),
                                        t("extends"),
                                        t("finally"),
                                        t("for"),
                                        t("import")),
                                      Or(t("is"),
                                        t("in"),
                                        t("let"),
                                        t("new"),
                                        t("package"),
                                        t("protected")),
                                      Or(t("public"),
                                        t("try"),
                                        t("using"),
                                        t("while"),
                                        t("yield")))) ++

        // OPERATORSORDERED BY PRECEDENCE https://introcs.cs.princeton.edu/java/11precedence/ z

        Nominal("AssignmentKeyword", Push("AssignmentKeyword", op("="))) ++
        Nominal("NotPreOperator", Push("NotPreOperator", op("!"))) ++
        Nominal("BitNotPreOperator", Push("BitNotPreOperator", op("~"))) ++
        Nominal("MinusPreOperator", Push("MinusPreOperator", op("-"))) ++
        Nominal("AsKeyword", Push("AsKeyword", Cons(t("as"), WS))) ++
        Nominal("IsKeyword", Push("IsKeyword", Cons(op("is"), WS))) ++
        Nominal("MulOperator", Push("MulOperator", Or(op("**"), op("*"), op("/"), op("%")))) ++
        Nominal("AddOperator", Push("AddOperator", Or(op("++"), op("+"), op("-")))) ++
        Nominal("ShiftOperator", Push("ShiftOperator", Or(op(">>>"), op(">>"), op("<<")))) ++
        Nominal("RelOperator", Push("RelOperator", Or(op(">="), op("<="), op(">"), op("<")))) ++
        Nominal("EqOperator", Push("EqOperator", Or(op("==="), op("!=="), op("~="), op("=="), op("!=")))) ++
        Nominal("BitAndOperator", Push("BitAndOperator", op("&"))) ++
        Nominal("BitXorOperator", Push("BitXorOperator", op("^"))) ++
        Nominal("BitOrOperator", Push("BitOrOperator", op("|"))) ++
        Nominal("AndKeyword", Push("AndKeyword", op("&&"))) ++
        Nominal("OrKeyword", Push("OrKeyword", op("||")))
        grammar = g
        g
    }
  }
}