import support::env
import support::test
import src::main
import src::tokens

#[export]
fun test(): void = {
  START("Parser tests")

  case1()
  case2()
  whitespaces()
  strings()

  END()
}

fun case1(): void = {
  START("case1")

  val p = parser("A  BCS C DEF ghi123  ")

  validateToken(p, Identifier, 1)
  validateToken(p, Whitespace, 2)
  validateToken(p, Identifier, 3)
  validateToken(p, Whitespace, 1)
  validateToken(p, Identifier, 1)
  validateToken(p, Whitespace, 1)
  validateToken(p, Identifier, 3)
  validateToken(p, Whitespace, 1)
  validateToken(p, Identifier, 6)
  validateToken(p, Whitespace, 2)
  validateToken(p, EndOfFile, 0)
  validateToken(p, EndOfFile, 0)

  END()
}

fun case2(): void = {
  START("Empty case")

  val p = parser("")

  validateToken(p, EndOfFile, 0)
  validateToken(p, EndOfFile, 0)

  END()
}

fun whitespaces(): void = {
  START("Whitespaces")

  val p = parser(" \n\r\t")

  validateToken(p, Whitespace, 1)
  validateToken(p, NewLine, 2)
  validateToken(p, Whitespace, 1)
  validateToken(p, EndOfFile, 0)

  END()
}


fun strings(): void = {
  START("Single quoted strings")

  val p = parser(" 'asd' ''  ")

  validateToken(p, Whitespace, 1)
  validateToken(p, SingleStringLiteral, 5)
  validateToken(p, Whitespace, 1)
  validateToken(p, SingleStringLiteral, 2)
  validateToken(p, Whitespace, 2)
  validateToken(p, EndOfFile, 0)

  END()
}

fun validateToken(p: Parser, token: TokenType, expectedSize: i32): void = {
  match p.eat() {
    case is Token(tokenType, start, end) -> {
      val given = TokenType.toString(tokenType)
      val expected = TokenType.toString(token)
      mustEqual(given, expected, "yield " ++ expected)
      mustEqual(expectedSize as u32, end - start, "Validate token size must match")
    }
  }
}
